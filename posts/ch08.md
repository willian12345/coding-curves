Coding Curves 08: BÃ©zier Curves

Chapter 8 of the Coding Curves Series

I had to hold myself back here. BÃ©zier curves are fun to program, fascinating to explore, and you can go down a deep hole in explaining how they are constructed and what the formulas mean. The thing is, Iâ€™ve already done that a few times. In books and in videos. Hereâ€™s a couple of my own videos you might want to check out to learn more:

è®©æˆ‘ä»¬å›åˆ°çœŸæ­£çš„æ›²çº¿ä¸Šæ¥ã€‚è´èµ›å°”æ›²çº¿ç¼–ç¨‹å°±éå¸¸æœ‰è¶£é¢†äººæ­¢ä¸ä½çš„æƒ³æ¢ç´¢ä¸€ç¿»ï¼Œ ä½ å¯ä»¥è‡ªå·±æ·±å…¥å­¦ä¹ å®ƒçš„ç»„æˆä»¥åŠç›¸åº”çš„å…¬å¼ã€‚åœ¨æˆ‘çš„è§†é¢‘æˆ–æˆ‘çš„ä¹¦é‡Œé¢è¿™äº›äº‹æˆ‘åšè¿‡å¾ˆå¤šæ¬¡äº†ã€‚ ä¸‹é¢æ˜¯æˆ‘åšçš„ä¸¤ä¸ªè§†é¢‘ä½ å¯ä»¥å…ˆçœ‹çœ‹ï¼š

https://www.youtube.com/watch?v=dXECQRlmIaE: Coding Curves 08: BÃ©zier Curves
https://www.youtube.com/watch?v=2hL1LGMVnVM: Coding Curves 08: BÃ©zier Curves

And here are a couple of amazing videos by Freya Holmer:
https://www.youtube.com/watch?v=aVwxzDHniEw: Coding Curves 08: BÃ©zier Curves
https://www.youtube.com/watch?v=jvPPXbo87ds: Coding Curves 08: BÃ©zier Curves

So Iâ€™m going to limit myself here to the bare basics, some functions, and some cool, practical tips and tricks Iâ€™ve discovered over the years.

æˆ‘è¿˜æ˜¯ä»…é™ä»‹ç»æœ€åŸºç¡€çš„ä¸€äº›å‡½æ•°ä»¥åŠè¿™äº›å¹´ç§¯ç´¯çš„ä¸€äº›å¾ˆé…·å®ç”¨æŠ€å·§ä¸ç»éªŒã€‚

The Basics

A BÃ©zier curve is defined by two end points and one or more control points. It starts at one end point, curves towards (but not through) the control point(s) and ends at the other end point. By moving any of the points, you alter the shape of the curve. These curves are generally visually pleasing and are used in all kinds of design tools, and are a key part of the shapes of things from fonts to cars.

There are two types of BÃ©zier curves that youâ€™ll run into most often.

## åŸºç¡€

è´å¡å°”æ›²çº¿ç”±ä¸¤ä¸ªç«¯ç‚¹å’Œä¸€ä¸ªæ§åˆ¶ç‚¹å®šä¹‰è€Œæˆã€‚å®ƒä»ä¸€ä¸ªç‚¹å‡ºå‘å‘æ§åˆ¶ç‚¹ï¼ˆä¸ç©¿è¿‡æ§åˆ¶ç‚¹ï¼‰å†è‡³å¦ä¸€ä¸ªç«¯ç‚¹ã€‚ä½ å¯ä»¥é€šè¿‡æ§åˆ¶è¿™äº›ç‚¹ä¸­çš„ä»»æ„æ”¹å˜æ›²çº¿çš„å½¢çŠ¶ã€‚è¿™äº›æ›²çº¿é€šå¸¸å¾ˆä¼˜ç¾ï¼Œåº”ç”¨äºå„ç§å„æ ·çš„è®¾è®¡å·¥å…·ï¼Œä»ç»˜åˆ¶æ–‡å­—åˆ°ç»˜åˆ¶æ±½è½¦ï¼Œå®ƒæ˜¯å„ç§å½¢çŠ¶ç»˜åˆ¶çš„å…³é”®ç»„æˆéƒ¨åˆ†ã€‚

Quadratic BÃ©zier Curves

These are defined by two end points and a single control point. Hereâ€™s an example:

## äºŒé˜¶è´å¡å°”æ›²çº¿

ä¸¤ä¸ªç«¯ç‚¹ä¸ä¸€ä¸ªæ§åˆ¶ç‚¹ç»„æˆï¼Œå¦‚ä¸‹ï¼š

![image](images/ch08/out-9.png);

The control point is the one near the bottom of the canvas. If I move that to the right, it changes the curve:

æ§åˆ¶ç‚¹é è¿‘ canvas åº•éƒ¨ã€‚å¦‚æœä½ æŠŠå®ƒç§»åŠ¨åˆ°å³è¾¹ï¼Œå®ƒä¼šå½±å“åˆ°æ›²çº¿ï¼š

![image](images/ch08/out-10.png);

The lighter lines and black points I just threw in for visual context.

ç»†ä¸€ç‚¹çš„çº¿å’Œé‚£ä¸ªç‚¹ä¸»è¦ç”¨äºå¯è§†åŒ–æ¼”ç¤ºæ§åˆ¶ç‚¹çš„ä½ç½®ã€‚

## Cubic BÃ©zier Curves

Cubic BÃ©zier Curves have two end points and two control points. Example:

## ä¸‰é˜¶è´å¡å°”æ›²çº¿

ä¸‰é˜¶è´å¡å°”æ›²çº¿æ‹¥æœ‰ä¸¤ä¸ªç«¯ç‚¹å’Œä¸¤ä¸ªæ§åˆ¶ç‚¹ï¼Œå¦‚å›¾ï¼š

![image](images/ch08/out-11.png);

It is possible to have higher order BÃ©zier curves with more control points, but the math gets more and more costly. See Freyaâ€™s videos above for some explanations about this.

Most drawing apis have methods for both quadratic and cubic curves, but how they are names varies greatly.

Iâ€™ve seen quadratic BÃ©zier curve methods named:

é«˜é˜¶è´å¡å°”æ›²çº¿æ‹¥æœ‰æ›´å¤šçš„æ§åˆ¶ç‚¹ï¼Œä½†èŠ±è´¹çš„è®¡ç®—æˆæœ¬ä¹Ÿç›¸åº”ä¼šå˜çš„æ›´é«˜ã€‚ å¯ä»¥çœ‹çœ‹ Freya çš„ç›¸å…³è§†é¢‘è®²è§£ã€‚

å¤§å¤šæ•°ç»˜å›¾ç¨‹åº api éƒ½æœ‰æä¾›äºŒé˜¶å’Œä¸‰é˜¶æ›²çº¿çš„å‡½æ•°ï¼Œä½†åå­—å¯èƒ½æœ‰æ¯”è¾ƒå¤§çš„å‡ºå…¥ã€‚

æˆ‘çœ‹è¿‡äºŒé˜¶è´å¡å°”æ›²çº¿çš„å‡½æ•°æœ‰è¢«å‘½åä¸ºï¼š

  * curveTo
  * quadraticCurveTo

And cubic BÃ©zier curve methods named:

ä¸‰é˜¶è´å¡å°”æ›²çº¿è¢«å‘½åä¸º:

  * curveTo
  * cubicCurveTo
  * bezierCurveTo

So make sure you know what the method names are for your api. A common strategy, as seen in the examples above, is to have the starting point defined by using a moveTo, or the last known position of the drawing cursor, and then have the curve method just define the control points and the final end point. So youâ€™d do something like:

ä½ å¾—ç¡®ä¿ä½ ä½¿ç”¨çš„ç¼–ç¨‹è¯­è¨€ç”¨çš„æ˜¯å“ªä¸€ä¸ªã€‚é€šå¸¸ä½ å¯ä»¥å‚è€ƒä¸Šé¢åˆ—å‡ºçš„å‡ ä¸ªä¾‹å­ï¼Œèµ·å§‹ç‚¹ç”¨ moveTo å®šä¹‰ï¼Œ å¦åˆ™èµ·ç‚¹å°†ä¼šæ˜¯ç»˜å›¾ api æœ€è¿‘ä¸€æ¬¡çš„ç»˜åˆ¶ç‚¹ï¼Œç„¶åè°ƒç”¨è´å¡å°”æ›²çº¿å‡½æ•°å®šä¹‰æ§åˆ¶ç‚¹ä¸ç»“æŸç‚¹ã€‚ä½ å¯ä»¥åƒä¸‹é¢è¿™ä¹ˆåšï¼š

```
moveTo(100, 100)
cubicCurveTo(200, 100, 200, 500, 100, 300)
stroke()
```

But some apis may have other methods that allow you to specify all the points at once.

Thatâ€™s about it for the basics and built-ins, but of course, weâ€™ll now leave the apis behind and code up some curves ourselves.

ä½†æœ‰äº›ç¼–ç¨‹è¯­è¨€å¯ä»¥å…è®¸ä½ ä¸€æ¬¡è®¾å®šæ‰€æœ‰ç‚¹ã€‚å®ƒæ˜¯ä½œä¸ºåŸºç¡€çš„å†…å»ºå‡½æ•°ï¼Œå½“ç„¶æˆ‘ä»¬è¿˜æ˜¯ä¼šå¿½ç•¥å…·ä½“å†…å»ºçš„ api æˆ‘ä»¬å¿…é¡»è‡ªå·±å®ç°ä¸€éã€‚



## Coding BÃ©zier Curves

Weâ€™ll start with quadratic curves and then move on to cubic. But before we create the methods that draw the paths, weâ€™re going to create another, more basic method. This will give us the point at any interval along the BÃ©zier curve.

## è´å¡å°”æ›²çº¿ç¼–ç 
æˆ‘ä»¬å…ˆä»äºŒé˜¶è´å¡å°”æ›²çº¿å¼€å§‹ç„¶åè½¬å‘ä¸‰é˜¶è´å¡å°”æ›²çº¿ã€‚ä½†åœ¨æˆ‘ä»¬å¼€å§‹ç”»æ›²çº¿è·¯å¾„å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå¦å¤–åˆ›å»ºä¸€ä¸ªåŸºç¡€å‡½æ•°ã€‚å®ƒä¼šæä¾›è´å¡å°”æ›²çº¿ä¸Šä»»æ„ç‚¹çš„ç‚¹çš„ä½ç½®ã€‚

## Quadratic

Interestingly, the basic formulas for BÃ©zier curves are one-dimensional. To make two-dimensional, three-dimensional or higher BÃ©zier curves, you just apply the formula once for each dimension. Weâ€™ll be sticking two 2D here, so weâ€™ll be doing this twice. The single parametric formula is:

## äºŒé˜¶è´å¡å°”æ›²çº¿

æœ‰è¶£çš„ä¸€ç‚¹æ˜¯è´å¡å°”æ›²çº¿åŸºç¡€å…¬å¼æ˜¯ä¸€ç»´çš„ã€‚ä¸ºè¾¾åˆ°äºŒç»´ï¼Œä¸‰å››ï¼Œæˆ–æ›´é«˜é˜¶ï¼Œä½ æƒéœ€ä¸ºæ¯ä¸€ç»´åº”ç”¨å…¬å¼ã€‚è¿™é‡Œæˆ‘ä»¬éœ€è¦ç”¨ä¸¤ä¸ªä¸€ç»´ç»„åˆæˆäºŒç»´ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†æ‰§è¡Œä¸¤æ¬¡ã€‚å•å‚æ•°å…¬å¼å¦‚ä¸‹ï¼š

```
x = (1 - t) * (1 - t) * x0 + 2 * (1 - t) * t * x1 + t * t * x2
```

Here, x0, x1, and x2 are the end and control â€œpointsâ€ and t is a value that ranges from 0.0 to 1.0. This returns the x value along the BÃ©zier path corresponding to the value of t. When t is 0, x is equal to x0. When t is 1, x is equal to x2. When t is between 0 and 1, x will be interpolated.

So to make a 2D quadratic BÃ©zier point function we do this:

æ­¤å¤„ï¼Œx0, x1, å’Œ x2 æ˜¯ä¸¤ä¸ªç«¯ç‚¹ä¸æ§åˆ¶ç‚¹ï¼Œt çš„å€¼èŒƒå›´æ˜¯ 0.0 åˆ° 1.0ã€‚ å®ƒä¼šæ ¹æ® t çš„å€¼è¿”å›è¿™æ¡è´å¡å°”æ›²çº¿ä¸Šå¯¹åº” x ç‚¹ã€‚ å½“ t ä¸º 0ï¼Œ x ç­‰äº x0ã€‚ å½“ t ä¸º 1ï¼Œ x ç­‰äº x2ã€‚ å½“ t åœ¨ 0 å’Œ 1 ä¹‹é—´æ—¶ï¼Œx ä¼šæ˜¯æ˜¯æ’å€¼ã€‚

æ‰€ä»¥è¦åˆ›å»ºä¸€ä¸ªäºŒé˜¶è´å¡å°”æ›²çº¿ç‚¹çš„å‡½æ•°åº”è¯¥åƒä¸‹é¢è¿™æ ·åšï¼š

```
function quadBezierPoint(x0, y0, x1, y1, x2, y2) {
  x = (1 - t) * (1 - t) * x0 + 2 * (1 - t) * t * x1 + t * t * x2
  y = (1 - t) * (1 - t) * y0 + 2 * (1 - t) * t * y1 + t * t * y2
  return x, y
}
```

You can do this if your language lets you return multiple values. Otherwise, youâ€™ll have to encode x, y in come kind of point object.

Note that we have a lot of duplication going on there. We can clean it up first factoring out all those 1-ts:

ä½ å¯ä»¥è¿™ä¹ˆåšï¼Œå¦‚æœä½ çš„ç¼–ç¨‹è¯­è¨€æ”¯æŒè¿”å›å¤šä¸ªå€¼çš„è¯ã€‚å¦åˆ™ä½ éœ€è¦å°†è¿”å›å€¼å˜æˆç±»ä¼¼ç‚¹å¯¹è±¡ã€‚

æ³¨æ„ï¼Œæˆ‘ä»¬å…ˆå»é‡ä¸€ä¸‹ã€‚æˆ‘ä»¬å¯ä»¥å…ˆæå– 1-t ä¸º m  å› å­ï¼š

```
function quadBezierPoint(x0, y0, x1, y1, x2, y2, t) {
  m = (1 - t)
  x = m * m * x0 + 2 * m * t * x1 + t * t * x2
  y = m * m * y0 + 2 * m * t * y1 + t * t * y2
  return x, y
}
```

And then

ç„¶å

```
function quadBezierPoint(x0, y0, x1, y1, x2, y2, t) {
  m = (1 - t)
  a = m * m
  b = 2 * m * t
  c = t * t
  x = a * x0 + b * x1 + c * x2
  y = a * y0 + b * y1 + c * y2
  return x, y
}
```

If nothing else, this makes it much easier to read.

Now that we have this, we can make a function to draw quadratic BÃ©zier curves. To make it perfectly clear, Iâ€™ll name this quadCurve and the cubic one will be cubicCurve

æ— å®ƒï¼Œå°±æ˜¯æ›´æ˜“è¯»ã€‚

æœ‰äº†å®ƒå°±å¯ä»¥ç”¨å®ƒç”»äºŒé˜¶è´å¡å°”æ›²çº¿äº†ã€‚ä¸ºäº†æ¸…æ™°çš„å®šä¹‰äºŒé˜¶ä¸ä¸‰é˜¶ï¼Œæˆ‘æŠŠå®ƒä»¬åˆ†åˆ«å‘½åä¸º quadCurve å’Œ cubicCurveã€‚ 

```
function quadCurve(x0, y0, x1, y1, x2, y2, res) {
  moveTo(x0, y0)
  for (t = res; t < 1; t += res) {
    x, y = quadBezierPoint(x0, y0, x1, y1, x2, y2, t)
    lineTo(x, y)
  }
  lineTo(x2, y2)
}
```

To make sure we explicitly start and end on the start and end points, weâ€™ll start with an explicit moveTo to the first point and end with an explicit lineTo to the last point. The function takes a res parameter that lets you know how many steps to take along the curve. Weâ€™ll start t out equaling res because weâ€™ve already moved to the first point, which is what youâ€™d get if t was 0. In the middle of all that, we just get the point corresponding to the current t and draw a line to it.

Of course, you can make a quadCurveTo method by dropping the first two parameters and the moveTo. This will rely on the user using their own moveTo to specify the starting point of the curve (or continuing it from an existing path). Example of this in use:

ç¡®ä¿åœ¨ quadCurve æˆ‘ä»¬å°†èµ·å§‹ç‚¹ä¸ç»“æŸç‚¹æ‹†å‡ºæ¥äº†ï¼Œæˆ‘ä»¬ moveTo æ‹†å‡ºç¬¬ä¸€ä¸ªç‚¹ï¼Œç”¨ lineTo æ‹†å‡ºæœ€åä¸€ä¸ªç‚¹ã€‚ å‡½æ•°æ¥å—ä¸€ä¸ª res å‚æ•°ï¼Œç”¨äºæŒ‡å®šæ²¿æ›²çº¿ä¸Šè¿­ä»£å¤šå°‘æ¬¡ã€‚æˆ‘ä»¬å°† t åˆå§‹å€¼ä¸º res å› ä¸ºå‡½æ•°å¤–å·²ç»ç§»åŠ¨åˆ°ç¬¬ä¸€ä¸ªç‚¹äº†ï¼Œæ— è®º t å€¼æ˜¯å¦ä¸º 0ã€‚ä¸­é—´çš„æ‰€æœ‰ç‚¹æ ¹æ®å½“å‰ t ç»˜åˆ¶å‡ºçº¿æ¡ã€‚

å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ª quadCurveTo å‡½æ•°å»æ‰å‡½æ•°å†…å‰ä¸¤ä¸ªå‚æ•°è¿˜æœ‰ moveToï¼ˆè¯‘è€…æ³¨ï¼šè¿™é‡Œå¹¶éæ˜¯è®©ä½ å»æ‰ï¼Œè€Œæ˜¯è®©ä½ è‡ªå·±å†³å®šæ˜¯å¦å•ç‹¬åœ¨å‡½æ•°å¤–é¢è°ƒç”¨ï¼‰ã€‚ è¿™å–å†³äºç”¨æˆ·è‡ªå·±æ˜¯å¦éœ€è¦æŒ‡å®šæ›²çº¿èµ·å§‹ç‚¹ï¼ˆæˆ–ä»å·²æœ‰çš„è·¯å¾„å¼€å§‹ç»˜åˆ¶ï¼‰ã€‚ä»¥ä¸‹æ˜¯è°ƒç”¨æ–¹å¼ï¼š

```
canvas(800, 800)
quadCurve(100, 100, 200, 700, 700, 300, 0.01)
stroke()
```

Which gives us:

è¿™ä¼šç”Ÿæˆå¦‚ä¸‹å›¾ï¼š

![image](images/ch08/image-3.png);

If we change the res to something larger like 0.1, we see that things get a bit chunky:

å¦‚æœ res å˜å¤§ä¸€ç‚¹ï¼Œåˆ™ä¼šç”Ÿæˆä¸€ä¸ªæœ‰ç‚¹ç³™çš„æ›²çº¿ï¼š

![image](images/ch08/image-4.png);

So here youâ€™ll have to experiment with a resolution value that works well. Given that the built-in BÃ©zier methods already figure out a good resolution for you, this curve method has questionable value. But, it got us to write the quadBezierPoint function, which has a LOT of value, as weâ€™ll see.

One thing that the point function can do that the built in methods canâ€™t is animation. For this section, like I did in previous chapters, Iâ€™m going to assume you have or can make some kind of function that runs repeatedly and can create animations. Iâ€™m going to call it loop. What Iâ€™m going to do here is rather than drawing the curve from a t of 0 to 1, Iâ€™ll have it go from 0 to a value finalT that will change over time.

ä½ å·²ç»å¯¹ res åˆ†è¾¨ç‡è¿™ä¸ªå€¼æœ‰ä¸€å®šç»éªŒäº†ã€‚å†…å»ºçš„è´å¡å°”æ›²çº¿ä¼šè‡ªåŠ¨ç»™å®šä¸€ä¸ªåˆé€‚çš„ res å€¼ã€‚ä½†æˆ‘ä»¬è‡ªå·±å®ç°çš„ quadCurve å‡½æ•°å†… res å€¼å¯èƒ½è¿˜æ˜¯æœ‰ç‚¹å„¿é—®é¢˜çš„ã€‚ä½†åœ¨æ­¤å¤„å¹¶ä¸é‡è¦ï¼Œå› ä¸ºå®ƒå·²ç»èƒ½è®© quadBezierPoint è¿”å›ç»™æˆ‘ä»¬è¶³å¤Ÿçš„åæ ‡å€¼äº†ï¼Œæ­£å¦‚ä½ æ‰€è§çš„è¿™æ ·ã€‚

æˆ‘ä»¬çš„ quadBezierPoint èƒ½ç”¨äºå®ç°åŠ¨ç”»ï¼Œè€Œå†…å»ºå‡½æ•°åšä¸åˆ°ï¼ˆè¯‘è€…æ³¨ï¼šå†…å»ºå‡½æ•°åªèƒ½ä¸€æ¬¡æ€§ç”»å‡ºè·¯å¾„ï¼‰ã€‚åœ¨è¿™ä¸€èŠ‚ï¼Œ å°±åƒä¹‹å‰ç« èŠ‚æˆ‘åšçš„é‚£æ ·ï¼Œ æˆ‘å·²ç»å‡å®šä½ æœ‰æˆ–æœ‰èƒ½åŠ›å®ç°æ— é™å¾ªç¯çš„å‡½æ•°ç”¨äºåˆ›å»ºåŠ¨ç”»äº†ã€‚ è¿˜æ˜¯å«å®ƒ loop å‡½æ•°ã€‚ æˆ‘ä¸ä¼šåƒä¹‹å‰é‚£æ ·ç”¨ t å®ç° 0 åˆ° 1 ç»˜åˆ¶æ›²çº¿ï¼Œæˆ‘å°† è®© t ä» 0 åˆ° finalT , finalT çš„å€¼ä¼šä¸€ç›´å˜åŒ–ã€‚

```
canvas(400, 400)
x0 = 50
y0 = 50
x1 = 150
y1 = 360
x2 = 360
y2 = 150
finalT = 0
dt = 0.01
res = 0.025
 
function loop() {
  clearCanvas()
  moveTo(x0, y0)
  for (t = res; t < finalT; t += res) {
    x, y = quadBezierPoint(x0, y0, x1, y1, x2, y2, t)
    lineto(x, y)
  }
  stroke()
 
  // add to finalT
  finalT += dt
 
  // if we go past 1, turn it around
  if (finalT > 1) {
    finalT = 1
    dt = -dt
  } else if (finalT < 0) {
    // if we go past 0, turn it back
    finalT = 0
    dt = -dt
  }
}
```

And this should give you an animation that looks something like this:

ç»“æœåº”è¯¥ä¼šåƒä¸‹é¢è¿™æ ·çš„åŠ¨ç”»

![image](images/ch08/out.gif);

Here, the for loop is going from res to finalT so it doesnâ€™t draw the entire curve (unless finalT equals 1). Then we change finalT by adding dt to it. This brings finalT closer and closer to 1, so the curve is drawn more and more fully. Eventually finalT will go beyond 1 so we set it back to 1 and make dt negative, which reverses the whole process until finalT goes below 0, where we bounce it back the other way.

Rather than just drawing a line, we can animate an object along a BÃ©zier path now! Hereâ€™s the code for that. It should be pretty clear. Iâ€™ll just include the loop function. The rest should be the same.

æ­¤å¤„ï¼Œ for ç¯å¢ƒå†… t æ˜¯ä» res åˆ° finalT å˜åŒ–çš„æ‰€ä»¥ä¸ä¼šç”»å‡ºå®Œæ•´çš„æ›²çº¿ï¼ˆé™¤é finalT ä¸º 1ï¼‰ã€‚ç„¶åæˆ‘ä»¬ç»™ finalT åŠ ä¸Š dtã€‚ è¿™ä¼šè®© finalT æ…¢æ…¢æ¥è¿‘ 1ï¼Œ è¿™ä¼šæ›²çº¿è¶Šæ¥è¶Šå®Œæ•´ã€‚å½“ finalT è¶…è¿‡ 1 æ—¶, æˆ‘ä»¬å°†å®ƒè®¾ä¸ºè´Ÿå€¼ï¼Œè¿™ä¼šè®©æ•´ä¸ªè¿‡ç¨‹åè½¬ç›´åˆ° finalT å˜ä¸º 0ï¼Œ è¿™æ˜¯æˆ‘ä»¬å˜å›å‡ºå‘ç‚¹çš„æ–¹æ³•ã€‚ï¼ˆè¯‘éƒ½æ³¨ï¼šå…¶å®å°±æ˜¯å½“ finalT è¶…è¿‡ä¸´ç•Œç‚¹åï¼Œé€šè¿‡å°† dt è®¾ä¸º -dt ä½¿å¾— finalT ä¸€ç›´åœ¨ 1 å’Œ 0 ä¹‹é—´æ¥å›å˜åŠ¨ï¼‰

ç›¸æ¯”äºç”»ä¸€æ¡çº¿ï¼Œ æˆ‘ä»¬è¿™æ¬¡åšä¸€ä¸ªæ²¿è´å¡å°”æ›²çº¿è¿åŠ¨çš„åŠ¨ç”»ï¼ä¸‹é¢æ˜¯ä»£ç ç¤ºä¾‹ã€‚ç›¸å½“æ¸…æ™°æ˜äº†ã€‚æˆ‘åªæ˜¯æ·»åŠ äº†ä¸€ä¸ªå®å¿ƒåœ†çš„é€»è¾‘æ”¾è¿› loop å‡½æ•°å†…ï¼Œå‰©ä¸‹çš„ä»£ç å’Œä¹‹å‰ä¸€æ ·ã€‚

```
function loop() {
  clearCanvas()
 
  x, y = quadBezierPoint(x0, y0, x1, y1, x2, y2, finalT)
  circle(x, y, 10)
  fill()
 
  // no changes beyond here...
  // add to finalT
  finalT += dt
 
  // if we go past 1, turn it around
  if (finalT > 1) {
    finalT = 1
    dt = -dt
  } else if (finalT < 0) {
    // if we go past 0, turn it back
    finalT = 0
    dt = -dt
  }
}
```

Now weâ€™re just getting the x, y point for the current value of finalT and drawing a circle there. This assumes you have a circle drawing function. You can use the one we created in Chapter 3 if you need one.

è¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº† finalT çš„å½“å‰å€¼å¯¹åº”ç‚¹çš„ x, y å¹¶åœ¨ x, y å¤„ç”»äº†ä¸ªåœ†ã€‚å‡å®šä½ å·²ç»æœ‰äº† circle ç»˜åˆ¶å‡½æ•°ã€‚ä½ å¦‚æœæœ‰éœ€è¦ä½ å¯ä»¥åœ¨ç¬¬ä¸‰ç« é‡Œå¤åˆ¶ä¸€ä¸ªè¿‡æ¥ã€‚

![image](images/ch08/out-1.gif);

In this example, I drew a light line for the same quadratic curve using the built-in method of my api, just to show that weâ€™re on track with the standard definitions of these things.

åœ¨ä¸‹é¢è¿™ä¸ª gif å›¾ï¼Œæ˜¯æˆ‘ç”¨å†…å»ºçš„å‡½æ•°ç»˜åˆ¶çš„ç›¸åŒæ›²çº¿ï¼Œå¤šæ¥äº†ä¸€æ¡ç»†çº¿è¡¨ç¤ºè¿åŠ¨è½¨é“å±•ç¤ºåŠ¨ç”»ä¸€ç›´åœ¨æˆ‘ä»¬æˆ‘ä»¬å®šä¹‰çš„æ ‡å‡†çš„äºŒé˜¶è´å¡å°”æ›²çº¿ä¸Šã€‚

![image](images/ch08/out-2.gif);

OK, letâ€™s take a break here and jump over to cubic curves

å¥½çš„ï¼Œç¨ä½œä¼‘æ¯åè®©æˆ‘ä»¬è¿›å…¥ä¸‰é˜¶è´å¡å°”æ›²çº¿ã€‚

##ã€€Cubic

Pretty much everything I said above for quadratic curves is going to apply to cubics. Itâ€™s just a different formula â€“ a bit more complicated. Here is is for one dimension:

## ä¸‰é˜¶è´å¡å°”æ›²çº¿

ä¸Šé¢ä»‹ç»çš„äºŒé˜¶è´å¡å°”æ›²çº¿éƒ½å°†åº”ç”¨åˆ°ä¸‰é˜¶ä¸Šã€‚åªæ˜¯å…¬å¼ä¸ä¸€æ · - æ›´å¤æ‚ä¸€ç‚¹ç‚¹ã€‚ä¸‹é¢æ˜¯ä¸€ç»´çš„å®šä¹‰ï¼š

```
x = (1 - t) * (1 - t) * (1 - t) * x0 + 3 * (1 - t) * (1 - t) * t * x1 + 3 * (1 - t) * t * t * x2 + t * t * t * x3
```

And the 2D function:

è¿˜æœ‰äºŒç»´å‡½æ•°çš„å®šä¹‰ï¼š

```
function cubicBezierPoint(x0, y0, x1, y1, x2, y2, x3, y3, t) {
  x = (1 - t) * (1 - t) * (1 - t) * x0 + 3 * (1 - t) * (1 - t) * t * x1 + 3 * (1 - t) * t * t * x2 + t * t * t * x3
  y = (1 - t) * (1 - t) * (1 - t) * y0 + 3 * (1 - t) * (1 - t) * t * y1 + 3 * (1 - t) * t * t * y2 + t * t * t * y3
  return x, y
}
```

Yikes! Thatâ€™s a mess. Letâ€™s clean it up again by factoring out the 1 - ts:

æ˜¯çš„çœ‹èµ·æ¥ç›¸å½“ä¹±ï¼Œæˆ‘ä»¬åŒæ ·æå–å‡º 1- t å› å­å‡ºæ¥æ•´ç†ä¸€ä¸‹ï¼š

```
function cubicBezierPoint(x0, y0, x1, y1, x2, y2, x3, y3, t) {
  m = 1 - t
  x = m * m * m * x0 + 3 * m * m * t * x1 + 3 * m * t * t * x2 + t * t * t * x3
  y = m * m * m * y0 + 3 * m * m * t * y1 + 3 * m * t * t * y2 + t * t * t * y3
  return x, y
}
```

Thatâ€™s a little better. One more step to clean it up:

å¥½ä¸€ç‚¹å„¿äº†ï¼Œæ›´è¿›ä¸€æ­¥ä¼˜åŒ–åï¼š

```
function cubicBezierPoint(x0, y0, x1, y1, x2, y2, x3, y3, t) {
  m = 1 - t
  a = m * m * m
  b = 3 * m * m * t
  c = 3 * m * t * t
  d = t * t * t
  x = a * x0 + b * x1 + c * x2 + d * x3
  y = a * y0 + b * y1 + c * y2 + d * y3
  return x, y
}
```

Much better!

Now we can make a cubicCurve function.

è¿˜å¯ä»¥ï¼

ç°åœ¨å¯ä»¥åˆ›å»º cubicCurve ä¸‰é˜¶è´å¡å°”æ›²çº¿å‡½æ•°äº†ã€‚

```
function cubicCurve(x0, y0, x1, y1, x2, y2, x3, y3, res) {
  moveTo(x0, y0)
  for (t = res; t < 1; t += res) {
    x, y = cubicBezierPoint(x0, y0, x1, y1, x2, y2, x3, y3, t)
    lineTo(x, y)
  }
  lineTo(x2, y2)
}
```
That was easy. No explanation or example needed I think.

Now for your assignment: adjust the animations we did above to work for cubic curves. Itâ€™s really just a matter of adding a new x3, y3 point and calling the new function.

Thatâ€™s the basic code for implementing BÃ©zier curves and paths. But there are a few more neat tricks for you.

å¾ˆç®€å•ã€‚æˆ‘æƒ³ä¸éœ€è¦æ›´å¤šçš„è§£é‡Šäº†ã€‚

ç°åœ¨ä½ çš„ä»»åŠ¡æ˜¯ï¼šè°ƒæ•´äºŒé˜¶åŠ¨ç”»ç”¨ä¸‰é˜¶æ¥å®ç°ä¸€éã€‚ä»…ä»…éœ€è¦åŠ ä¸€ä¸ªã€€x3, y3 çš„æ–°åæ ‡ç‚¹å¹¶è°ƒç”¨è¿™ä¸ªæ–°å‡½æ•°ã€‚

è¿™äº›å°±æ˜¯å¯¹è´å¡å°”æ›²çº¿å’Œè·¯å¾„çš„åŸºç¡€ä»£ç å®ç°äº†ã€‚ä½†æˆ‘è¿™é‡Œè¿˜å‡†å¤‡äº†ä¸€äº›å…¶å®ƒæœ‰ç”¨çš„å°æŠ€å·§ç»™ä½ ã€‚

## Drawing Through a Point

At some point, everyone who starts coding BÃ©zier curves is going to say:

> This is neat, but I want it to go THROUGH the control point(s). Me â€“ some time around the year 2000.

Well, we can do that! Itâ€™s pretty easy for quadratic curves. What you need to do is create another control point that will pull the curve even further out so that it just goes through the original control point. And that new point is pretty simple to calculate. Where the points are x0, y0, x1, y1, x2, y1, the new control point will be:

## è¿‡ç‚¹ç”»çº¿

é‚£äº›åˆšå¼€å§‹ä½¿ç”¨è´å¡å°”æ›²æ¥çº¿ç¼–ç¨‹çš„äººç»å¸¸ä¼šè¯´

> è¿™å¾ˆå·§å¦™ï¼Œä½†æˆ‘å¸Œæœ›æ›²çº¿èƒ½ç©¿è¿‡æ§åˆ¶ç‚¹ ---- è¿™ä¹Ÿæ˜¯æˆ‘-å¤§çº¦åœ¨ 2000 å¹´å·¦å³æƒ³è¦å®ç°çš„åŠŸèƒ½

å½“ç„¶å¯ä»¥å®ç°äº†ï¼è¿™å¯¹äºŒé˜¶è´å¡å°”æ›²çº¿ç›¸å½“å®¹æ˜“å®ç°ã€‚ä½ åªéœ€è¦åœ¨æ›´è¿œçš„åœ°æ–¹åˆ›å»ºå¦ä¸€ä¸ªæ§åˆ¶ç‚¹ï¼Œæ§åˆ¶æ›²çº¿åˆšå¥½ç©¿è¿‡åŸæ§åˆ¶ç‚¹çš„ä½ç½®ã€‚æ–°çš„æ§åˆ¶ç‚¹å¾ˆå®¹æ˜“è®¡ç®—ã€‚ä»¥ç‚¹ x0, y0, x1, y1, x2, y1 ä¸ºä¾‹ï¼Œé‚£ä¹ˆæ–°æ§åˆ¶ç‚¹ä¼šæ˜¯ï¼š

```
x = x1 * 2 - x0 / 2 - x2 / 2
y = y1 * 2 - x0 / 2 - x2 / 2
```

Now we can make a function, letâ€™s call it quadCurveThrough that implements this behavior. It just gets this new point and uses the built-in function to draw the curve. Iâ€™m going to postulate thatâ€™s called quadraticCurveTo on your system, but it might be something else.

ç°åœ¨æˆ‘ä»¬å¯ä»¥åˆ›å»ºåœ°ä¸€ä¸ªæ–°å‡½æ•° quadCurveThrough å®ç°ä¸Šé¢çš„ä»£ç å…¬å¼ã€‚ä¸‹é¢æ˜¯è®¡ç®—è·å–æ–°æ§åˆ¶ç‚¹å¹¶ä½¿ç”¨å†…å»ºå‡½æ•°å®ç°è´å¡å°”æ›²çº¿ç»˜åˆ¶ã€‚æˆ‘å‡å®šä½ çš„ç³»ç»Ÿä¸­ä¹Ÿæœ‰åä¸º quadraticCurveTo çš„å‡½æ•°ï¼Œå½“ç„¶ä¹Ÿå¯èƒ½åå­—ä¸åŒã€‚


```
function quadCurveThrough(x0, y0, x1, y1, x2, y2) {
  xc = x1 * 2 - x0 / 2 - x2 / 2
  yc = y1 * 2 - y0 / 2 - y2 / 2
  moveTo(x0, y0)
  quadraticCurveTo(xc, yc, x2, y2)
}
```

Here Iâ€™ve drawn a regular quadratic curve in red and one using this function in blue. And I drew in the points to prove that it does what I claim it does!

ä¸‹å›¾ä¸­çº¢çš„æ˜¯æˆ‘ç”¨æ ‡å‡†çš„äºŒé˜¶è´å¡å°”æ›²çº¿ç”»çš„ï¼Œè“çš„æ˜¯ç”¨æ–°å‡½æ•°ç”»çš„ã€‚å¹¶ä¸”ç»˜åˆ¶äº†é‚£äº›æ§åˆ¶ç‚¹ç”¨äºè¯æ˜ã€‚

![image](images/ch08/image-6.png);

Your next question is how to do the same thing for cubic curves. I donâ€™t have an answer for that one yet. But I will keep digging. I guess thereâ€™s a chance that someone will comment the answer here, or tell me itâ€™s not possible. ğŸ™‚

ä½ ä¸‹ä¸€ä¸ªé—®é¢˜ä¸€å®šæ˜¯å¦‚ä½•åœ¨ä¸‰é˜¶è´å¡å°”æ›²çº¿å®ç°åŒæ ·çš„è¿‡æ§åˆ¶ç‚¹ç»˜åˆ¶æ›²çº¿ã€‚æˆ‘æš‚æ—¶è¿˜ä¸çŸ¥é“ï¼Œä½†æˆ‘ä¼šä¸€ç›´æ¢ç´¢ã€‚æˆ‘çŒœè¿™ä¹Ÿæ˜¯ä¸€ä¸ªæœºä¼šï¼Œä¹Ÿè®¸æœ‰äººä¼šåœ¨è¯„è®ºåŒºç»™å‡ºç­”æ¡ˆï¼Œæˆ–ç›´æ¥å‘Šè¯‰æˆ‘è¿™ä¸å¯èƒ½å®ç°ğŸ™‚

## Piece-wise Quadratic BÃ©zier Curves

The other question people commonly ask is:

> How do I make a BÃ©zier curve with N control points (where N is 3 to infinity)? Also me around the same time as earlier question

## åˆ†æ®µäºŒé˜¶è´å¡å°”æ›²çº¿

äººä»¬é€šå¸¸ä¼šé—®çš„å¦ä¸€ä¸ªé—®é¢˜æ˜¯ï¼š

> æˆ‘å¦‚ä½•ç»˜åˆ¶ N ä¸ªæ§åˆ¶ç‚¹çš„è´å¡å°”æ›²çº¿ï¼ˆN ä¸º 3 åˆ° æ— ç©·ï¼‰ï¼Ÿæ—©æœŸè¿™ä¸ªé—®é¢˜ä¹Ÿå›°æ‰°ç€æˆ‘

As mentioned earlier, this is mathematically possible, but it gets prohibitively expensive when you move past cubic. Thatâ€™s why youâ€™ll probably never see quartic or quintic BÃ©zier curve functions. But itâ€™s still a very useful thing to have a smooth curve with an arbitrary number of control points. And of course youâ€™ve seen this kind of thing any time youâ€™ve used a pen tool in a drawing program.

æ­£å¦‚æˆ‘ä¹‹å‰æåˆ°è¿‡çš„ï¼Œåœ¨æ•°å­¦ä¸Šæ˜¯å¯è¡Œçš„ï¼Œä½†å¯ä»¥è‚¯å®šçš„æ˜¯ä»ä¸‰é˜¶å¾€ä¸Šå®ƒç›¸å½“æ¶ˆè€—æ€§èƒ½ã€‚è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆä½ å‡ ä¹æ²¡æ€ä¹ˆè§è¿‡å››é˜¶è´å¡å°”æ›²çº¿å‡½æ•°ã€‚ä½†å¯¹äºåˆ›å»ºä¸€æ¡æ‹¥æœ‰ä»»æ„æ§åˆ¶ç‚¹çš„å¹³æ»‘æ›²çº¿è¿˜æ˜¯éå¸¸æœ‰ç”¨çš„ã€‚å½“ç„¶ï¼Œä½ è‚¯å®šå·²ç»åœ¨æŸäº›ç»˜å›¾è½¯ä»¶ç”¨è¿‡â€œé’¢ç¬”â€è¿™ç§ç±»å·¥å…·äº†ã€‚

In the splines video above (second one by Freya), she shows making a longer curve by piecing together multiple cubic BÃ©zier curves.

åœ¨ä¸Šé¢è§†é¢‘æ ·æ¡æ›²çº¿ï¼ˆç¬¬äºŒä¸ªä½œè€…ä¸º Freyaï¼‰ï¼Œ å¥¹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨å¤šä¸ªä¸‰é˜¶è´èµ›å°”æ›²çº¿ç»„æˆé•¿æ›²çº¿ï¼ˆæ ·æ¡æ›²çº¿ï¼‰

https://www.youtube.com/watch?v=jvPPXbo87ds: Coding Curves 08: BÃ©zier Curves

These are sometimes called piecewise BÃ©zier curves. Iâ€™m going to show you something a bit simpler, using only quadratic curves. Itâ€™s not too hard to implement and it supports any number of control points you want to throw at it. Iâ€™ll even show you a version that creates a closed loop.

æœ‰æ—¶è¢«ç§°ä¸ºåˆ†æ®µäºŒé˜¶è´å¡å°”æ›²çº¿ï¼Œæˆ‘å°†å±•ç¤ºä¸€ç‚¹ç®€å•çš„ä¾‹å­ä½¿ç”¨äºŒé˜¶æ›²çº¿ã€‚å®ƒçš„å®ç°å¹¶ä¸éš¾ä¸”å®ƒæ”¯æŒä»»æ„å¤šçš„æ§åˆ¶ç‚¹ã€‚æˆ‘ç”šè‡³ä¼šä¸ºä½ åˆ›å»ºä¸€ä¸ªæ›²çº¿é—­ç¯çš„ç‰ˆæœ¬ã€‚

This technique is actually covered in depth in the second video I posted above (by me):
è¿™é¡¹æŠ€æœ¯åœ¨æˆ‘çš„è§†é¢‘ä¸­è®²è¿‡äº†ï¼š
https://www.youtube.com/watch?v=2hL1LGMVnVM: Coding Curves 08: BÃ©zier Curves

So Iâ€™m not going to do too deep a dive here, but Iâ€™ll go over the basics and give you some code and examples.

The basic principle is youâ€™re going to first create a new point that is mid-way between p0 and p1. Call that pA. And another thatâ€™s between p1 and p2. Call that pB. Draw a line from p0 to pA, then draw a quadratic curve using pA, p1 and pB. 

æ‰€ä»¥åœ¨æ­¤å¤„æˆ‘ä¸ä¼šæ·±å…¥å¤ªå¤šï¼Œä»…è¦†ç›–åŸºç¡€éƒ¨åˆ†å¹¶ç»™ä½ ä¸€äº›ç¤ºä¾‹ã€‚

åŸºæœ¬åŸåˆ™æ˜¯åœ¨ â€œp0 p1â€ ä¹‹é—´ç”»åˆ›å»ºä¸€ä¸ªä¸­ç‚¹ç§°ä¸º pAã€‚ç„¶åå†åˆ›å»ºä¸€ä¸ª p1 ä¸ p2 ä¹‹é—´çš„ä¸­ç‚¹è®¾ä¸º pB ã€‚è¿æ¥ p0 åˆ° pAï¼Œç„¶åä½¿ç”¨ pAï¼Œp1 å’Œ pB ç»˜åˆ¶äºŒé˜¶è´å¡å°”æ›²çº¿ã€‚

![image](images/ch08/image-13.png);

Then youâ€™ll get midpoint from p2 and p3, called pC and make a curve from pB through p2 and ending at pC. 

ç„¶åä½ æ‰¾åˆ° p2 å’Œ p3 ä¹‹é—´çš„ pC å¹¶ä¸”ä» pB ç»˜åˆ¶äºŒé˜¶è´å¡å°”æ›²çº¿é€šè¿‡æ§åˆ¶ç‚¹ p2 åˆ°è¾¾ pC

![image](images/ch08/image-14.png);

Youâ€™ll continue that until the end where you draw a curve from the second-to-last midpoint, through the second-to-last point, ending at the last midpoint. Then finally a line from the last midpoint to the last point.

ç»§ç»­ä»¥ä¸Šæ­¥éª¤ç›´åˆ°å€’æ•°ç¬¬äºŒä¸ªä¸­é—´ç‚¹ï¼Œç©¿è¿‡å€’æ•°ç¬¬äºŒç‚¹ï¼Œç»“æŸåœ¨æœ€åä¸€ä¸ªä¸­é—´ç‚¹ã€‚æœ€ç»ˆè¿æ¥æœ€åä¸€ä¸ªä¸­é—´ç‚¹åˆ°æœ€åä¸€ä¸ªç»“æŸç‚¹ã€‚


![image](images/ch08/image-15.png);

And hereâ€™s the curve:

ä¸‹é¢æ˜¯ç”»å‡ºçš„æ›²çº¿ï¼š

![image](images/ch08/image-16.png);

The code for this can get a little tricky, but having worked through it a few times, Iâ€™m pretty happy with a method that looks like the following. Note, that due to the potentially large number of parameters that will be passed in, it really helps to have some kind of point object. Whether thatâ€™s a class, structure, or generic object with x and y properties.. up to you and your language. This method will take an array of these point objects. The code assumes the array has a length property, but there might be something different in your language, like a len method.

å®ç°è¿™ä¸ªæ•ˆæœçš„ä»£ç çœ‹èµ·æ¥æœ‰ç‚¹å„¿æ£˜æ‰‹ï¼Œä½†æˆ‘å·²ç»å¼„è¿‡å¥½å‡ å›äº†ï¼Œå¾ˆåº†å¹¸å·²ç»æœ‰äº†åƒä¸‹é¢è¿™æ ·çš„å‡½æ•°ã€‚æ³¨æ„ï¼Œä¸ºäº†èƒ½ä¼ é€’å¤§é‡å‚æ•°ï¼Œ å‚æ•°éœ€è¦å®šä¹‰æˆæŸç§ç±»å‹çš„å¯¹è±¡ã€‚æ— è®ºå®ƒæ˜¯ç±»ï¼Œç»“æ„ï¼Œæˆ–æ‹¥æœ‰x, y å±æ€§çš„æ™®é€šå¯¹è±¡...ã€‚æ ¹æ®ä½ è‡ªå·±ä½¿ç”¨çš„ç¼–ç¨‹è¯­è¨€é€‰æ‹©å§ã€‚æ­¤å‡½æ•°ä½¿ç”¨æ•°ç»„å­˜å‚¨åæ ‡ç‚¹ã€‚å‡å®šæ•°ç»„æœ‰ä¸ª length å±æ€§ï¼Œåœ¨ä½ çš„ç¼–ç¨‹è¯­è¨€ä¸­æœ‰å¯èƒ½å®ƒä¸æ˜¯ä¸€ä¸ªå±æ€§ï¼Œè€Œæ˜¯ä¸€ä¸ªè·å–æ•°ç»„é•¿åº¦çš„æ–¹æ³•ã€‚

```
function multiCurve(points) {
  // line from the first point to the first midpoint.
  // è¿æ¥ç¬¬ä¸€ä¸ªç‚¹åˆ°ç¬¬ä¸€ä¸ªä¸­é—´ç‚¹
  moveTo(points[0].x, points[0].y)
  midX = (points[0].x + points[1].x) / 2
  midY = (points[0].y + points[1].y) / 2
  lineTo(midX, midY)
 
  // loop through the points array, starting at index 1
  // and ending at the second-to-last point
  // å¾ªç¯æ•°ç»„ï¼Œindex ä» 1 å¼€å§‹è‡³å€’æ•°ç¬¬äºŒä¸ªç‚¹ç»“æŸ
  // ï¼ˆè¯‘è€…æ³¨ï¼šæ³¨æ„è¿™å¾ªç¯å†…çš„æœ€å¼€å§‹çš„ p0 å…¶å®æ˜¯æ•°ç»„ä¸­çš„ç¬¬äºŒä¸ªç‚¹äº†ï¼‰
  for (i = 1; i < points.length - 1; i++) {
    // find the next two points and their midpoint
    p0 = points[i]
    p1 = points[i+1]
    midX = (p0.x + p1.x) / 2
    midY = (p0.y + p1.y) / 2
 
    // curve through next point to midpoint
    // ä»ä¸‹ä¸€ä¸ªç‚¹å¼€å§‹ç»˜åˆ¶äºŒé˜¶æ›²çº¿è‡³ä¸­é—´ç‚¹
    quadraticCurveTo(p0.x, p0.y, midX, midY)
  }
 
  // we'll be left at the last midpoint
  // draw line to last point
  // è¿æ¥æœ€åä¸€ä¸ªä¸­é—´ç‚¹åˆ°ç»“æŸç‚¹ã€‚
  p = points[points.length - 1]
  lineTo(p.x, p.y)
}
```

That method seems long, but I added a lot of comments to each part.

For an example, I generated a half dozen random points. I donâ€™t know how youâ€™d do that on your system, so Iâ€™m going to say we have a function randomPoint(xmin, ymin, xmax, ymax). (Actually I do have such a method in my own library!) Once you have your points array, you just pass that array to your new function and stroke the resulting path:

æ–¹æ³•çœ‹èµ·æ¥æœ‰ç‚¹å„¿é•¿ï¼Œä½†æˆ‘ä¸ºæ¯éƒ¨åˆ†åŠ äº†å¯¹åº”çš„æ³¨é‡Šã€‚

å¦‚ä¸‹ä¾‹å­ä¸­ï¼Œæˆ‘æ·»åŠ äº†åŠæ‰“ï¼ˆè¯‘è€…æ³¨ï¼šä¸€æ‰“æ˜¯ 12 ä¸ª åŠæ‰“ æ˜¯ 6 ä¸ªï¼‰éšæœºåæ ‡ç‚¹ã€‚æˆ‘ä¸çŸ¥é“ä½ ä½¿ç”¨çš„ç¼–ç¨‹è¯­è¨€ä¸­å¦‚ä½•ç”Ÿæˆè¿™äº›éšæœºæ•°ï¼Œæˆ‘å‡å®šä½ ä¼šæœ‰ randomPoint(xmin, ymin, xmax, ymax) è¿™æ ·çš„å‡½æ•°ã€‚ï¼ˆäº‹å®ä¸Šæˆ‘åœ¨è‡ªå·²å‡½æ•°åº“ä¸­ç¡®å®å®ç°è¿‡è¿™æ ·çš„å‡½æ•°ï¼ï¼‰ä¸€æ—¦ä½ æœ‰äº†è¿™æ ·çš„æ•°ç»„ï¼ŒæŠŠæ•°ç»„ä¼ è¿› multiCurve åå†è°ƒç”¨ stroke è¿›è¡Œæè¾¹æ¸²æŸ“ï¼š

```
context(800, 800)
points = []
for (i = 0; i < 6; i++) {
  points.push(randomPoint(0, 0, 800, 800))
}
 
multiCurve(points)
stroke()
```

The glorious result:

çœ‹çœ‹è¿™å›¾ï¼š

![image](images/ch08/image-17.png);

Quite nice. I also drew all the points to give a bit more context on why the curve looks like it does.

ç›¸å½“ä¸é”™ã€‚ æ›²çº¿ä¹‹æ‰€ä»¥çœ‹èµ·æ¥æ˜¯æ ·ï¼Œæ˜¯å› ä¸ºåœ¨ç”Ÿæˆè¿™äº›éšæœºæ•°çš„æ•°ç»„æ—¶ä¹Ÿæ˜¯è¦æ ¹æ®ä¸Šä¸‹æ–‡ç¯å¢ƒæ¥çš„

## Closed Curves

The final thing in this section will be to alter the method to allow for a closed loop. Mainly thatâ€™s going to be getting rid of the starting and final line segments, and figuring out the curve from the end of the curve back to the beginning.

## å°é—­æ›²çº¿

æœ€åéƒ¨åˆ†å°†è¦ä»‹ç»çš„æ˜¯å¦‚ä½•å°†å‡½æ•°æ”¹é€ æˆå°é—­æ›²çº¿ã€‚ä¸»è¦æ˜¯å»é™¤æ‰å¼€å§‹ä¸ç»“æŸçº¿æ–­ï¼Œå¹¶ä¸”å°†å®ƒé¦–å°¾ç›¸è¿ã€‚

```
function multiLoop(points) {
  // find the first midpoint and move to it.
  // we'll keep this around for later
  // æ‰¾åˆ°æœ€å¼€å§‹çš„é‚£ä¸ªä¸­é—´ç‚¹ï¼Œå°†ç»˜åˆ¶ç‚¹ç§»è‡³æ­¤ç‚¹ã€‚
  // å…ˆå­˜ä¸‹æ¥åé¢ä¼šç”¨åˆ°
  midX0 = (points[0].x + points[1].x) / 2
  midY0 = (points[0].y + points[1].y) / 2
  moveTo(midX0, midY0)
 
  // the for loop doesn't change
  // å¾ªç¯å’Œä¹‹å‰ä¸€æ ·ä¸ç”¨å˜
  for (i = 1; i < points.length - 1; i++) {
    p0 = points[i]
    p1 = points[i+1]
    midX = (p0.x + p1.x) / 2
    midY = (p0.y + p1.y) / 2
    quadraticCurveTo(p0.x, p0.y, midX, midY)
  }
 
  // we'll be left at the last midpoint
  // find the midpoint between the last and first points
  // æ‰¾åˆ°æ•°ç»„é¦–å°¾é—´çš„ä¸­é—´ç‚¹
  p = points[points.length - 1]
  midX1 = (p.y + points[0].x) / 2
  midY1 = (p.y + points[0].y) / 2
 
  // curve through the last point to that new midpoint
  // å°†æœ€åä¸€ä¸ªç‚¹ä¸é¦–å°¾ä¸­é—´ç‚¹ç›¸è¿
  quadraticCurveTo(p.x, p.y, midX1, midY1)
 
  // then curve through the first point to that first midpoint you saved earlier
  // ç„¶åå†å°†æ•°ç»„ç¬¬ä¸€ä¸ªç‚¹ä¸æ—©å‰æˆ‘ä»¬ä¿å­˜çš„ç¬¬ä¸€ä¸ªä¸­é—´ç‚¹è¿æ¥
  quadraticCurveTo(points[0].x, points[0].y, midX0, midY0)
}
```

![image](images/ch08/image-19.png);

We move to the first midpoint, then loop through the rest, finding midpoints and doing quadratic curves. This leaves us at the last midpoint. Thenâ€¦

æˆ‘ä»¬å…ˆä»ç¬¬ä¸€ä¸ªä¸­é—´ç‚¹å¼€å§‹ï¼Œå¾ªç¯å‰©ä¸‹çš„ç‚¹ï¼Œæ‰¾åˆ°å„è‡ªç‚¹çš„ä¸­é—´ç‚¹å¹¶ç”¨äºŒé˜¶è´å¡å°”æ›²çº¿ç›¸è¿ã€‚æˆ‘ä»¬æœ€ç»ˆåœç•™åœ¨æœ€åä¸€ä¸ªä¸­é—´ç‚¹ã€‚ç„¶å...

![image](images/ch08/image-20.png);

We find the midpoint between the first and last points, and execute the last two curves to close up the shape. The following image is made with the same setup as the last one, but calling multiLoop instead of multiCurve (and different random points).

æ‰¾åˆ°é¦–å°¾é—´çš„ä¸­é—´ç‚¹ï¼Œå¹¶å°†å‰©ä¸‹ä¸¤æ®µæ›²çº¿è¿åœ¨ä¸€èµ·å°†å½¢çŠ¶é—­åˆã€‚å¦‚ä¸‹å›¾ä¸ä¸Šé¢ä¸€æ ·çš„è®¾ç½®ä¸€æ ·ï¼Œä½†ç”¨ multiLoop å‡½æ•°å–ä»£äº†ä¹‹å‰çš„ multiCurveå‡½æ•° ï¼ˆéšæœºå‡ºçš„ points æ•°ç»„å€¼ä¹Ÿä¸ä¸€æ ·ï¼‰ã€‚

![image](images/ch08/image-18.png);

These are two of my favorite functions, and Iâ€™m happy to share them with you.

è¿™æ˜¯æˆ‘æœ€çˆ±çš„å‡½æ•°ï¼Œæˆ‘å¾ˆä¹æ„åˆ†äº«ç»™ä½ ä»¬ã€‚

## Even Distribution

The final trick I want to share has to do with evenly distributing objects on a quadratic curve. One use case for this is when you want to have text follow a curve. You want to be able to space the letters evenly on the curve. Youâ€™ll also want to rotate them to follow the curve, but thatâ€™s beyond the scope of this article.

At first this might seem like a trivial problem. You have your t value that you use to divide up the curve. If you want, say, 20 object spaced out on the curve, just have them 0.05 apart. 20 x 0.05 = 1.0. Work done. Well, letâ€™s try it.

## å‡åŒ€åˆ†å¸ƒ

æœ€åè¦åˆ†äº«çš„æŠ€å·§æ˜¯å¦‚ä½•åœ¨äºŒé˜¶è´å¡å°”æ›²çº¿ä¸­å‡åŒ€åœ°åˆ†å¸ƒå¯¹è±¡ã€‚ ä¸€ä¸ªå®ç”¨çš„ä¾‹å­æ˜¯è¦æŠŠæ–‡æœ¬æ”¾åˆ°æ›²çº¿ä¸Šå¹¶ä¸”å‡åŒ€çš„åˆ†å¸ƒã€‚å½“ç„¶ä½ è‚¯å®šå¸Œæœ›æ–‡æœ¬çš„è§’åº¦ä¹Ÿæ ¹æ®æ›²çº¿çš„ä½ç½®è·Ÿç€æ—‹è½¬ç›¸åº”çš„è§’åº¦ï¼Œä½†è¿™ä¸€éƒ¨åˆ†è¶…å‡ºäº†æœ¬ç¯‡æ–‡ç« çš„è®¨è®ºèŒƒå›´ã€‚

ä¹ä¸€çœ‹å¾ˆå®¹æ˜“å®ç°ã€‚ä½ å¯ä»¥ç”¨ t æ¥åˆ†å‰²æ›²çº¿ã€‚å¦‚æœä½ æƒ³åœ¨æ›²çº¿ä¸Šç»™ 20 ä¸ªå¯¹è±¡ç•™å‡ºç©ºé—´ï¼Œ æ¯ä¸ªå¯¹è±¡å  0.05 ä»½ã€‚ 20 x 0.05 = 1.0ã€‚ æå®šã€‚è®©æˆ‘ä»¬è¯•è¯•ï¼š

```
canvas(800, 800)
 
x0 = 100
y0 = 700
x1 = 100
y1 = 100
x2 = 700
y2 = 400
 
moveTo(x0, y0)
quadraticCurveTo(x1, y1, x2, y2)
stroke()
 
// 20 evenly spaced t values (21 counting the end one)
// 20 ä¸ªç­‰è·çš„ t å€¼ï¼ˆç®—ä¸Šæœ€åä¸€ä¸ªæ˜¯21ä¸ªï¼‰
for (t = 0; t <= 1; t += 0.05) {
  x, y = quadBezierPoint(x0, y0, x1, y1, x2, y2, t)
  circle(x, y, 6)
  fill()
}
```

Hereâ€™s what that gives us.

ä¸‹é¢æ˜¯æˆ‘ä»¬å¾—åˆ°çš„ç»“æœï¼š

![image](images/ch08/image-21.png);

Not evenly spaced at all. The ones near the ends are spaced out and in the middle they are closer together. Thatâ€™s just the way it is with BÃ©zier curves. So, we have to figure out a way to get those points evenly spaced.

Sadly, thereâ€™s not a very easy way to do this. Iâ€™m going to give you a horribly un-optimized, brute force way to get decent results, and a couple of hints on how to make it better.

So, to get evenly spaced points along a curve, it makes sense that you need to know the length of the curve. If the length is 200 pixels, and you want 20 points, you put one point every 10 pixels along the length of the curve.

Surprisingly, there is no simple formula to get the length of a BÃ©zier curve. But we can get pretty close by sampling a bunch of points along the curve and getting the distance between each pair. This would look something like this:

æœ€ç»ˆæ²¡æœ‰å‡åˆ†ã€‚å°¾éƒ¨é—´éš”è¾ƒå¤§ï¼Œä¸­é—´é—´éš”åˆæ¯”è¾ƒç´§ã€‚è¿™å°±æ˜¯è´å¡å°”æ›²çº¿çš„ç‰¹ç‚¹ã€‚æ‰€ä»¥æˆ‘ä»¬å¾—æ‰¾åˆ°æ–¹æ³•è®©è¿™äº›ç‚¹å¹³å‡åˆ†å¸ƒã€‚

é—æ†¾çš„æ˜¯æ²¡æœ‰ä»€ä¹ˆç®€å•çš„æ–¹å¼æ¥å®ç°ã€‚æˆ‘å°†ç”¨ç²—æš´çš„æ–¹å¼å¼ºè¡Œå®ç°å®ƒï¼Œå½“ç„¶ä¹Ÿä¼šç»™ä½ ä¸€äº›ç”¨äºä¼˜åŒ–å®ƒçš„æç¤ºã€‚

ä¸ºäº†åœ¨æ›²çº¿ä¸Šå‡åˆ†ç­‰è·ç©ºæ ¼ï¼Œç›´è§‰å‘Šè¯‰æˆ‘ä»¬éœ€è¦å…ˆè·å–æ›²çº¿çš„æ€»é•¿åº¦ã€‚å¦‚æœé•¿åº¦æ˜¯ 200 åƒç´ ï¼Œ ä½ æƒ³è¦ 20 ä¸ªç‚¹å‡åˆ†ï¼Œ é‚£ä¹ˆæ¯é—´éš” 10 åƒç´ å°±æ”¾ä¸€ä¸ªã€‚

æ„å¤–çš„æ˜¯æ²¡ä»€ä¹ˆç°æˆçš„å…¬å¼å¯ä»¥åœ¨è´å¡å°”æ›²çº¿å®ç°è¿™ä¸€æ•ˆæœã€‚ä½†æˆ‘ä»¬å¯ä»¥åœ¨æ›²çº¿ä¸Šé‡‡æ ·ä¸€å †çš„ç‚¹ï¼Œè·å–æ¯ä¸ªç‚¹ä¹‹é—´çš„è·ç¦»æ¥æ¨¡æ‹Ÿå®ç°ã€‚ä»£ç å¤§è‡´å¦‚ä¸‹ï¼š

```
function quadBezLength(x0, y0, x1, y1, x2, y2, count) {
  length = 0.0
  dt = 1.0 / count
  x, y = x0, y0
  for (t = dt; t < 1; t += dt) {
    xn, yn = quadBezierPoint(x0, y0, x1, y1, x2, y2, t)
    length += distance(x, y, xn, yn)
    x, y = xn, yn
  }
  // (è¯‘è€…æ³¨ï¼šè¿™é‡ŒåŸä½œè€…ç”¨äº† '==' æ‰“é”™å­—äº†, åº”è¯¥æ˜¯ '+=')
  length += distance(x, y, x2, y2)
  return length
}
```

Here, count is how many samples we want to take. The more samples, the more accurate weâ€™ll be.

Then, dt is the amount to increase t by as we loop through the curve.

We keep track of the last point, x, y, which will start as x0, y0. Then we loop through the curve getting each new point, xn, yn and finding the distance between the last point and the new point, then making the new point the last point. Iâ€™m not going to show you how to find the distance between two points, just assuming that you have a function for that. You add that distance to the accumulating length.

Then you do one last length addition for x2, y2. Then return the length.

Make sure that all makes sense first, because Iâ€™m going to throw something else in there.

Itâ€™s going to be very useful to keep track of what the length was at each point as we work through the curve. So weâ€™re going to store each successive value in an array. And rather than returning the total length, weâ€™ll return the array.

å˜é‡ count æ˜¯é‡‡æ ·æ•°é‡ã€‚é‡‡æ ·è¶Šå¤šï¼Œè¶Šç²¾å‡†ã€‚

ç„¶å dt æ˜¯æˆ‘ä»¬åœ¨æ›²çº¿ä¸Šå¾ªç¯è¿­ä»£çš„æ­¥é•¿ã€‚

æˆ‘ä»¬è¿½è¸ªæ¯ä¸€æ­¥å¾ªç¯çš„ x, y ç‚¹ï¼Œåˆå§‹å€¼æ˜¯ x0, y0 ã€‚ç„¶åå¾ªç¯è¿­ä»£å¾—åˆ°æ›²çº¿ä¸Šæ¯ä¸€ä¸ªæ–°åæ ‡ç‚¹ xn, yn å¹¶è®¡ç®—å‡ºä¸Šä¸€æ¬¡è¿­ä»£ç‚¹åˆ°æ­¤æ—¶æ–°ç‚¹çš„è·ç¦»ï¼Œ ç„¶åå†å°†æ–°å€¼èµ‹å€¼ç»™ x, yã€‚ä¸æˆ‘æ‰“ç®—å±•ç¤ºå¦‚ä½•è®¡ç®—ä¸¤ç‚¹é—´çš„è·ç¦» ï¼Œæˆ‘å‡å®šä½ å·²ç»æœ‰è¿™æ ·çš„å‡½æ•°äº†ã€‚å°†è·ç¦»ç´¯åŠ è¿› length.

æœ€åå†å°†ç®—æœ€åx2, y2 ä¸ x, y æœ€åå€¼çš„è·ç¦»åŠ åˆ° length ä¸Šã€‚ç„¶åè¿”å› length ç»“æœ

ç¡®ä¿ä½ å®Œå…¨æ˜ç™½äº†ï¼Œå› ä¸ºæˆ‘å·²å‡†å¤‡åœ¨æ­¤å¤„æ·»åŠ æ›´å¤šä»£ç äº†ã€‚

æ²¿æ›²çº¿è¿½è¸ªæ¯ä¸ªç‚¹çš„è·ç¦»éå¸¸æœ‰ç”¨ã€‚æ‰€ä»¥æˆ‘ä»¬è¦æŠŠè¿™äº›è·ç¦»å­˜è¿›æ•°ç»„ã€‚è¿™æ¯”è¿”å›æ•´ä¸ªé•¿åº¦æœ‰ç”¨ï¼Œæˆ‘ä»¬å°†ç›´æ¥è¿”å›è¿™ä¸ªæ•°ç»„

```
function quadBezLengths(x0, y0, x1, y1, x2, y2, count) {
  lengths = []
  length = 0.0
  dt = 1.0 / count
  x, y = x0, y0
  for (t = dt; t < 1; t += dt) {
    xn, yn = quadBezierPoint(x0, y0, x1, y1, x2, y2, t)
    length += distance(x, y, xn, yn)
    lengths.push(length)
    x, y = xn, yn
  }
  length == distance(x, y, x2, y2)
  lengths.push(length)
  return lengths
}
```

Now the full length of the curve is in the last element, but we have a whole bunch of other sub-lengths too. Hereâ€™s what we do.

ç°åœ¨æ›²çº¿çš„å®Œæ•´é•¿åº¦å­˜åœ¨äº†æœ€åçš„æ•°ç»„å…ƒç´ ä¸­ï¼Œå¹¶ä¸”æˆ‘ä»¬è¿˜æœ‰ä¸€å †å…¶å®ƒé•¿åº¦ï¼Œä¸‹é¢çœ‹æˆ‘å¦‚ä½•åº”ç”¨ï¼š

```
count = 500
lengths = quadBezLengths(x0, y0, x1, y1, x2, y2, count)
length = lengths[count-1]
 
for (i = 0.0; i <= 1; i += 0.05) {
  // the length of the curve up to the next point
  // æ›²çº¿ä¸Šä¸‹ä¸€ä¸ªç›®æ ‡ç‚¹çš„é•¿åº¦
  targetLength = i * length
 
  // loop through the array until the length is higher than the target length
  // å¾ªç¯æ•°ç»„ç›´åˆ° length é«˜äºç›®æ ‡é•¿åº¦
  for (j = 0; j < count; j++) {
    if (lengths[j] > targetLength) {
      // t is now the percentage of the way we got through the array.
      // this is the t value we need to get the next point
      // t ç°åœ¨æ˜¯æ•°ç»„çš„ç™¾åˆ†æ¯”
      // è¿™æ˜¯ä¸‹ä¸€ä¸ªç‚¹çš„ t å€¼
      t = j / count
 
      // get the point and draw the next circle.
      // è·å–ä¸‹ä¸€ä¸ªç‚¹ï¼Œå¹¶ç»˜åˆ¶åœ†ã€‚
      x, y = quadBezierPoint(x0, y0, x1, y1, x2, y2, t)
      circle(x, y, 6)
      fill()
      break
    }
  }
}
```

OK, a bit complex, but letâ€™s go through it. We get the lengths using a count of 500, and capture the total length.

The we loop through from 0 to 1 by 0.05, like we were doing before. But rather than using that as the t value of the BÃ©zier curve, we use it to find a fraction of the length of the curve. Say the curve was 500 pixels long and i was 0.5, then the target length we are looking for is 250 for the next point.

Now we loop through the array with j and get the length values until we go above our target length. If we divide j by count, we wind up with the t value that created this particular length. We plug that back into the BÃ©zier point function to get the next point and draw it. We also want to break out of the inner loop at that point, since we are done and can move on to the next point.

This gives us the following:

å¥½çš„ï¼Œæœ‰ç‚¹å„¿å°å¤æ‚ï¼Œ è®©æˆ‘ä»¬è¿‡ä¸€éä»£ç ã€‚æˆ‘ä»¬ç”¨è®¾ count ä¸º 500 é‡‡æ ·å¾—åˆ°äº†é•¿åº¦æ•°ç»„ï¼Œä¸”è·å–äº†æ€»é•¿åº¦ã€‚ã€‚

å°±åƒä¹‹å‰ä¸€æ ·åˆ›å»ºäº†ä¸€ä¸ª 0.05 ä¸ºæ­¥é•¿ ä» 0 è‡³ 1 çš„å¾ªç¯ã€‚ä½†å¹¶ä¸åƒåœ¨ç”»è´å¡å°”æ›²çº¿æ—¶ä½¿ç”¨çš„ tï¼Œ æˆ‘ä»¬ç”¨å®ƒå¯»æ‰¾æ›²çº¿é•¿åº¦çš„ç™¾åˆ†æ¯”ã€‚æ„æ€æ˜¯å½“æ›²çº¿é•¿åº¦ä¸º 500 åƒç´ ä¸” i ä¸º 0.5 æ—¶ï¼Œæˆ‘ä»¬å¯»æ‰¾çš„çš„ç›®æ ‡ç‚¹é•¿åº¦å³ä¸º 250 åƒç´ ã€‚

ç°åœ¨æˆ‘ä»¬ç”¨å¾ªç¯éå†æ•°ç»„ é€šè¿‡ j è·å–é•¿åº¦å€¼ç›´åˆ°å€¼å¤§äº targetLength ç»“æŸå†…å¾ªç¯ã€‚æˆ‘ä»¬å°† j / count å¾—åˆ°è¿™ä¸€éƒ¨åˆ†ç‰¹å®šçš„é•¿åº¦ã€‚æˆ‘ä»¬ t ä¼ å…¥ quadBezierPoint å‡½æ•°å¾—åˆ°ä¸‹ä¸€ä¸ªç‚¹å¹¶æŠŠå®ƒç»˜åˆ¶å‡ºæ¥ã€‚æ­¤æ—¶æˆ‘ä»¬åº”è¯¥è·³å‡ºå†…éƒ¨çš„å¾ªç¯ï¼Œç›´åˆ°å®Œæˆè¿™äº›å†å…¥ä¸‹ä¸€æ­¥å¾ªç¯ã€‚

![image](images/ch08/out-14.png);

We missed the last point (because we never went beyond that length), but we could just draw another point at x2, y2. This is pretty close to evenly spaced. The higher the value you use for count, the more accurate it will be. If we move count down to 100, we can see itâ€™s off:

å¿˜äº†è¿˜æœ‰æœ€åä¸€ä¸ªç‚¹ï¼ˆå› ä¸ºå¾ªç¯å¹¶æœªè¶…è¿‡å®ƒçš„é•¿åº¦ï¼‰ï¼Œä½†æˆ‘ä»¬ä»…éœ€è¦å†ç»˜åˆ¶å¦ä¸€ä¸ªåæ ‡åœ¨ x2, y2 çš„ç‚¹å³å¯ã€‚è¿™å›ç›¸å½“æ¥è¿‘å‡åˆ†äº†ã€‚ count å€¼è®¾çš„è¶Šé«˜ï¼Œå‡åˆ†çš„ç²¾åº¦å°±ä¼šè¶Šé«˜ã€‚å¦‚æœ count é™ä¸º 100 ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹ä¸‹å®ƒçš„æ•ˆæœï¼š

![image](images/ch08/out-16.png);

Now, there is a LOT wrong with this code. Mostly in its optimization.

ç°åœ¨ï¼Œä»£ç ä¸­æœ‰è®¸å¤šé”™è¯¯ã€‚å¤§å¤šæ˜¯ä¼˜åŒ–ä¸Šçš„ã€‚

First of all, rather than looping through from 0 on each point, we could use a binary search.

é¦–å…ˆï¼ŒäºŒåˆ†æŸ¥è¯¢å°±æ¯”ä» 0 å¼€å§‹å¾ªç¯æ•´ä¸ªæ•°ç»„è¦å¥½ã€‚

Secondly, we have to add a lot of points to get any kind of accuracy. Because we are just grabbing the last point we find in that inner loop. Instead of taking a predefined point, which we know is a bit too high, we could interpolate between that point and the previous point.

å…¶æ¬¡ï¼Œæˆ‘ä»¬ä¸å¾—ä¸æ·»åŠ ä¸€å¤§å †ä»»æ„ç²¾åº¦çš„ç‚¹ã€‚ç”¨äºåœ¨å†…å¾ªç¯ä¸­åŒ¹é…æŸ¥æ‰¾ã€‚å–ä¸€ä¸ªé¢„å®šä¹‰çš„ç‚¹å¤ªè´¹æ€§èƒ½äº†ï¼Œ æˆ‘ä»¬å¯ä»¥åœ¨è¿™ä¸ªç‚¹ä¸å‰ä¸€ä¸ªç‚¹ä¹‹é—´æ’å€¼ã€‚

For example, say our target length was 150. And at index 87 we got a length of 160. We look back at index 86 and we find 140. OK, so we want a value half way in between 86 and 87. So instead of calculating t as 87 / count, or even 86 / count, we interpolate 50% and say 86.5 / count. It still wonâ€™t be perfect, but you can use a lower count and still get good results.

ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬çš„ç›®æ ‡é•¿åº¦æ˜¯150ï¼Œç„¶ååœ¨ index 87 ä½ç½®æˆ‘ä»¬å¾—åˆ°äº†é•¿åº¦æ˜¯å€¼æ˜¯ 160ã€‚ index å¾€å›åˆ° 86 æˆ‘ä»¬å¾—åˆ° 140ã€‚ç°åœ¨æˆ‘å¸Œæœ›å¾—åˆ° 86 ä¸ 87 ä¸­é—´çš„å€¼ã€‚ æ¯”èµ·ç”¨ 87 / count ï¼Œ æˆ– 86 / count ï¼Œæˆ‘ä»¬ç”¨æ’å€¼ 50% å³ 86.5 / countã€‚è™½ç„¶è¿˜æ˜¯ä¸å¤ªå®Œç¾ï¼Œä½†ä½ ç°åœ¨å¯ä»¥å°† count è®¾ä½ä¸€ç‚¹ï¼Œä½†å¾—åˆ°ç»“æœå´ä¾æ—§å¾ˆå¥½ã€‚

Iâ€™m going to leave all of that as an exercise for you.

If you want more info on this technique, and a fuller explanation, check out this site:

æˆ‘å°†è¿™äº›å·¥ä½œå½“ä½œç»ƒä¹ ç•™ç»™ä½ 

å¦‚æœä½ æƒ³è·å–æ›´å¤šè¿™ç±»ç›¸å…³çš„æŠ€æœ¯ä¿¡æ¯å’Œå®Œæ•´è§£é‡Šï¼Œå¯ä»¥å‚è€ƒä»¥ä¸‹ç½‘ç«™

http://www.planetclegg.com/projects/WarpingTextToSplines.html


## Summary

So there, you go, a few basics, a few tips, a few tricks. Until next timeâ€¦

å°±åˆ°è¿™é‡Œäº†ï¼Œä¸€äº›åŸºç¡€çŸ¥è¯†ï¼Œä¸€äº›å°æç¤ºï¼Œä¸€äº›å°æŠ€å·§ï¼Œä¸‹ä¸€ç« è§...