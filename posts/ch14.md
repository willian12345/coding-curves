# ç¬¬åå››ç«  å…¶å®ƒæ›²çº¿ï¼ˆMiscellaneous Curvesï¼‰
> åŸä½œï¼šKeith Peters https://www.bit-101.com/blog/2022/11/coding-curves/
>
> è¯‘è€…ï¼šæ± ä¸­ç‰©ç‹äºŒç‹—(sheldon)
>
> blog: http://cnblogs.com/willian/
>
> æºç ï¼šgithub: https://github.com/willian12345/coding-curves

Coding Curves 14: Miscellaneous Curves

Chapter 14 of Coding Curves

This is the last planned chapter of this series. I might add another one here or there in the future if I find a new interesting curve to write about. There were also a couple of topics on my original list which I decided to hold back. I might change my mind about them someday. Any future additions will be added to the index.

For this â€œfinalâ€ installment, I thought Iâ€™d cover a few random curves that probably wouldnâ€™t be worth a full chapter in themselves. And I thought it would be good to kind of walk through the process I actually take when I go to code up some formula I discover.

æ›²çº¿è‰ºæœ¯ç¼–ç¨‹ç³»åˆ— ç¬¬åå››ç« 

è¿™æ˜¯æœ«ç³»åˆ—æ–‡ç« è§„åˆ’çš„æœ€åä¸€ç« ã€‚å¦‚æœåé¢æ‰¾åˆ°å…¶å®ƒæœ‰è¶£çš„æ›²çº¿ç±»å‹å¯èƒ½åŠ åœ¨è¿™ä¸€ç« ï¼Œä¹Ÿå¯èƒ½å¦èµ·ä¸€ç« ã€‚æˆ‘åŸæœ¬è®¡åˆ’æ¸…å•é‡Œæœ‰å‡ ä¸ªä¸»é¢˜æˆ‘å†³å®šä¿ç•™ä¸‹æ¥ï¼Œä¹Ÿä¸æ’é™¤æŸå¤©æˆ‘æ”¹ä¸»æ„äº†ã€‚æœªæ¥é¢å¤–çš„å†…å®¹ä¹Ÿå¯èƒ½å¦èµ·ä¸€ç« åŠ åˆ°ç›®å½•ç´¢å¼•ä¸­ã€‚

åœ¨â€œæœ€åâ€ä¸€ç¯‡ï¼Œ æˆ‘æƒ³æˆ‘ä¼šè®²ä¸€äº›éšæœºæ›²çº¿ï¼Œè¿™äº›æ›²çº¿ä¸å€¼å¾—å•ç‹¬å¼€ä¸€ç« æ¥è®²ã€‚æˆ‘è§‰å¾—æŠŠæˆ‘æ‰¾åˆ°å…¬å¼ç¼–ç çš„è¿‡ç¨‹è®²ä¸€éä¼šå¾ˆå¥½

## The Cannabis Curve

## å¤§éº»æ›²çº¿

![image](./images/ch14/image-2.png)


Weisstein, Eric W. â€œCannabis Curve.â€ From MathWorldâ€“A Wolfram Web resource. https://mathworld.wolfram.com/CannabisCurve.html

Wolfram Mathworld is a great place to find interesting formulas by the way. If you want to dig up more 2d curves, the section on Plane Curves is a great place to dive in. But thereâ€™s all kinds of other stuff on the site too.

Iâ€™m not trying to make any statement by choosing the cannabis curve. I just thought it was pretty cool that you could draw something complex like that with relatively simple math.

So we get this as a formula:

Weisstein, Eric W "å¤§éº»æ›²çº¿" æ¥æºäºç½‘ç«™ <https://mathworld.wolfram.com/CannabisCurve.html>

Wolfram Mathworld æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„å‘æ˜æœ‰è¶£å…¬å¼çš„åœ°æ–¹ï¼Œé¡ºä¾¿è¯´ä¸€å¥ï¼Œå¦‚æœä½ æƒ³å‘æ˜æ›´å¤š 2d æ›²çº¿ï¼Œé‚£ä¹ˆåœ¨å¹³é¢æ›²çº¿ï¼ˆPlane Curveï¼‰è¿™ä¸€ç« èŠ‚å¯ä»¥æ·±å…¥æ‰¾æ‰¾ã€‚å½“ç„¶è¿™ä¸ªç½‘ç«™ä¹Ÿæœ‰å¾ˆå…¨çš„å…¶å®ƒæ›²çº¿ç±»å‹ã€‚

åœ¨é€‰æ‹©å¤§éº»æ›²çº¿æ—¶æˆ‘æ²¡æƒ³è¿‡è¦è¯´æ˜ä»€ä¹ˆé—®é¢˜ã€‚æˆ‘åªæ˜¯è§‰å¾—å®ƒå¾ˆé…·ï¼ˆè¯‘è€…æ³¨ï¼šæœ¬äººåœ¨æ­¤ç”³æ˜åšå†³åå¯¹ä¸€åˆ‡æ¯’å“ï¼‰ï¼Œä»…ä»…ç”¨ç®€å•çš„ç›¸å…³åœ°æ•°å­¦å…¬å¼å°±å¯ä»¥ç”»å‡ºå¦‚æ­¤å¤æ‚çš„ä¸œè¥¿ã€‚

ä¸‹é¢æ˜¯å¯¹åº”çš„æ•°å­¦å…¬å¼ï¼š

![image](./images/ch14/image-1.png)

OK, itâ€™s a bit long, but itâ€™s just multiplication, addition and some sines and cosines. We can do this.

This is defined as a polar curve, which means rather than defining x, y values, weâ€™ll be dealing with an angle and a radius. We have a function, r(Î¸), where Î¸ is the Greek letter, theta. This usually represents an angle. And we can guess that r stands for radius. So we have a function where we pass in an angle and get a radius.

With an angle and a radius, we can easily get an x, y point to draw a segment to. This might look sort of like this:

å¥½çš„ï¼Œå…¬å¼æœ‰ç‚¹å„¿é•¿ï¼Œä½†å®ƒåªæ˜¯ä¹˜æ³•ï¼ŒåŠ æ³•è¿˜æœ‰ä¸€äº›æ­£å¼¦å’Œä½™å¼¦è®¡ç®—ã€‚æˆ‘ä»¬å¯ä»¥çš„ã€‚

å®ƒå®šä¹‰äº†ä¸€æ¡æåæ ‡æ›²çº¿ï¼Œè¿™æ„å‘³ç€ç›¸æ¯”äº x, y çš„å€¼ï¼Œæˆ‘ä»¬æ›´å…³å¿ƒè§’åº¦ä¸åŠå¾„ã€‚æˆ‘ä»¬æœ‰ä¸ªå‡½æ•° `r(Î¸)`, `Î¸` æ˜¯å¸Œè…Šå­—æ¯ï¼Œthetaã€‚å®ƒé€šå¸¸ä»£è¡¨è§’åº¦ã€‚å½“ç„¶æˆ‘ä»¬ä¹Ÿèƒ½çŒœåˆ° r ä»£è¡¨åŠå¾„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‡½æ•°ä¼ å…¥è§’åº¦å¾—åˆ°å¯¹åº”çš„åŠå¾„ã€‚

æœ‰äº†è§’åº¦å’ŒåŠå¾„ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“è®¡ç®—å‡ºç”¨äºç»˜åˆ¶çº¿æ®µçš„ x,y ç‚¹ã€‚ç»„ç»‡ä»£ç ååº”è¯¥åƒä¸‹é¢åœ¨è¿™æ ·ï¼š

```
for (t = 0; t < 2 * PI; t += 0.01) {
  radius = r(t)
  x = cos(t) * radius
  y = sin(t) * radius
  lineTo(x, y)
}
stroke()
```

We use t to get the radius and then radius and t to get the next point to draw a line to.

Practically speaking though, Iâ€™ll never use that r(Î¸) function anywhere but in this for loop, so Iâ€™ll just hard code it all right there.

The only other thing we see here that isnâ€™t a number or a bracket or a trig formula or Î¸, is the variable a. Weâ€™re multiplying the whole rest of the formula by a to get the final radius for a given t, so it seems like a will just represent the overall radius we want this curve to be drawn at. So a will probably be a good parameter to pass into our cannabis function, and Iâ€™ll probably rename that parameter radius for clarityâ€™s sake. Weâ€™ll also probably want a center x, y point to locate the curve, so weâ€™ll make those parameters too (xc and yc for x and y center).

We come up with something like this for starters

æˆ‘ä»¬é€šè¿‡ t è®¡ç®—å¾—åˆ°åŠå¾„ï¼Œç„¶åå†é€šè¿‡åŠå¾„å’Œ t è®¡ç®—å¾—åˆ°ä¸‹ä¸€ä¸ªç»˜åˆ¶çº¿æ¡çš„åæ ‡ç‚¹ã€‚

ä¸è¿‡äº‹å®ä¸Šæ¥è®²ï¼Œr(Î¸) é™¤äº†åœ¨è¿™ä¸ªå¾ªç¯å†…ä¸ä¼šåœ¨å…¶å®ƒä»»ä½•åœ°æ–¹ä½¿ç”¨ï¼Œæˆ‘å°±ç›´æ¥ç¡¬ç¼–ç åœ¨è¿™é‡Œäº†ã€‚

æ­¤å¤„å”¯ä¸€é¢å¤–çš„ä¸œè¥¿å°±æ˜¯éœ€è¦ç”¨éœ€è¦ä¼ å…¥å‚æ•° radius  ç”¨ radius ä¹˜ä»¥å…¬å¼ã€‚è¿˜éœ€è¦ç”¨ x, y è®©æ›²çº¿å±…äºä¸­å¿ƒç‚¹ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¹ŸæŠŠå®ƒä½œä¸ºå‚æ•°ä¼ é€’ï¼ˆxc ä¸ yc ä»£è¡¨ x å’Œ y ä¸­ç‚¹ï¼‰ã€‚

ä»¥ä¸‹é¢ä»£ç ä½œä¸ºèµ·ç‚¹ï¼š

```
function cannabis(xc, yc, radius) {
  for (t = 0; t < 2 * PI; t += 0.01) {
    r = radius * ... // that whole formula. we'll get to it.
    x = cos(t) * r
    y = sin(t) * r
    lineTo(xc + x, yc + y)
  }
  closePath()
}
```

Now we just need to code up all the stuff that comes after a. This is really pretty simple now that weâ€™ve figured out how itâ€™s all going to fit together. For the fractional constants, Iâ€™ll just use decimals: 0.1 instead of 1/10 and 0.9 instead of 9/10. Letâ€™s go!

ç°åœ¨ï¼Œæˆ‘ä»¬åœ¨ä¸Šé¢åŸºç¡€ä¸Šè¿›è¡Œç¼–ç ã€‚ç›¸å½“ç®€å•æˆ‘ä»¬åªéœ€ä»£å…¥å…¬å¼ã€‚åˆ†æ•°éƒ¨åˆ†æˆ‘ä»¬ä½¿ç”¨ 0.1 ä»£æ›¿ 1/10, 0.9 ä»£æ›¿ 9/10ã€‚å¼€å§‹å§ï¼

```
function cannabis(xc, yc, radius) {
  for (t = 0; t < 2 * PI; t += 0.01) {
    r = radius * (1 + 0.9 * cos(8 * t)) * (1 + 0.1 * cos(24 * t)) * (0.9 + 0.1 * cos(200 * t)) * (1 + sin(t))
    x = cos(t) * r
    y = sin(t) * r
    lineTo(xc + x, yc + y)
  }
  closePath()
}
```

Now Iâ€™ll try to run this by putting up something like so:

ç°åœ¨ï¼Œåƒä¸‹é¢ä»£ç è¿™æ ·çœ‹çœ‹ï¼š

```
canvas(600, 600)
cannabis(300, 300, 140)
stroke()
```
That gives me this image:

![image](./images/ch14/out.png)

Ah, OK. This tells us a few things.

First, this formula is using Cartesian coordinates and Iâ€™m using upside-down screen coordinates. So Iâ€™ll have to flip the y-axis. No problem.

Next, the center is where all the â€œleavesâ€ join. So after flipping, I can probably set the center more towards the bottom of the canvas.

Finally, I guessed that 140 would be a good value for radius, as it would keep it well within the 600Ã—600 size of the canvas. In fact, I expected it would only be about half the size of the canvas. But we actually go well beyond the canvas edge for the larger leaves. We could correct that in the code, maybe multiplying radius by some fraction to bring the largest leaf down to the radius the user passed in. Iâ€™m going to skip that part and just pass in a smaller value, but feel free to do what you want with the function.

Hereâ€™s my final version:

Ah, å¥½çš„ï¼Œæœ‰ç‚¹å„¿ä¸œè¥¿ã€‚



```
function cannabis(xc, yc, radius) {
  for (t = 0; t < 2 * PI; t += 0.01) {
    r = radius * (1 + 0.9 * cos(8 * t)) * (1 + 0.1 * cos(24 * t)) * (0.9 + 0.1 * cos(200 * t)) * (1 + sin(t))
    x = cos(t) * r
    y = sin(t) * r
    lineTo(xc + x, yc - y)
  }
  closePath()
}
```

All I did was change the lineTo function to use yc - y instead of yc + y.

Then when I call it, I just change the parameters a bit (with a bit of trial and error to get it just right):

```
canvas(600, 600)
cannabis(300, 520, 120)
stroke()
```

![image](./images/ch14/out-1.png)

There we go!

Side note. I seriously considered changing the size of the canvas so that the yc parameter could be 420. Youâ€™ll either get that or you wonâ€™t. ğŸ™‚

Of course, now Iâ€™m curious about what that formula is doing. Thereâ€™s basically four parts to it after the a, each in parentheses â€“ three with cosines, one with sine. The first one has a hard coded 8 in there. 

```
... (1 + 0.9 * cos(8 * t)) ...
```

Since there are seven visible leaves there, Iâ€™m guessing those are related â€“ thereâ€™s probably actually eight leaves, but the bottom one is too small to see. Iâ€™ll change that 8 to a 12â€¦

![image](./images/ch14/out-2.png)

Yup, theory validated. Eleven leaves plus an invisible one.

In the second section, the 24 is a bit less obvious.

```
... (1 + 0.1 * cos(24 * t)) ...
```

If I revert back to original and then change the 24 to 0, I get very rounded leaves.

![image](./images/ch14/out-3.png)

Doubling 24 to 48 gives us:

![image](./images/ch14/out-4.png)

Itâ€™s kind of making three levels for each leaf. Letâ€™s put it back to 24 and change the multiplier:

```
... (0.7 + 0.3 * cos(24 * t)) ...
```

![image](./images/ch14/out-5.png)

Again, we see three levels, which make sense, as 24 = 8 * 3. So this section is using a very small multiplier, 0.1, to make a subtle change to each leaf â€“ making it just a bit less round. Cool. Weâ€™ll revert that and look at the next one.

```
... (0.9 + 0.1 * cos(200 * t)) ...
```

The 200 there makes me guess itâ€™s creating all the jagged edges. If I change it to 100, itâ€™s less jagged.

![image](./images/ch14/out-6.png)

But now Iâ€™m seeing some blockiness. I can try increasing the resolution by changing the for loop increment from 0.01 to 0.005:

![image](./images/ch14/out-7.png)

Mmmmâ€¦ smooth.

Iâ€™ll revert that and look at the final sine block.

```	
... (1 + sin(t))
```

My guess was that this was affecting the orientation of the curve. I thought that if I removed that section, the leaf would be sideways. But I was wrong. Hereâ€™s what happens if I remove that section and set yc back to 300, the center of the canvas:

![image](./images/ch14/out-8.png)

That was a pleasant surprise! And it gives me a lot of ideas of new curves I can create from this. Also, this makes that missing eighth leaf visible!

## A Heart Curve

![image](./images/ch14/image-3.png)

Weisstein, Eric W. â€œHeart Curve.â€ From MathWorldâ€“A Wolfram Web Resource. https://mathworld.wolfram.com/HeartCurve.html

Again, Wolfram Mathworld to the rescue. As you can see, there is no single formula to draw a heart shaped curve. This page shows eight different ones. Personally I like the last one in the second row.

Rather than a polar formula like last time (and some of these other examples), this just has us computing the x and y directly. But weâ€™re still going to loop a t value from 0 to 2 * PI.

For the y part of the formula, there are four different calculations. Itâ€™s not entirely clear how these calculations are supposed to be combined, but if you look further down in the text, you find that youâ€™re supposed to subtract them. Iâ€™m also a bit concerned that we have so many hard coded numbers in there and no way to change the final size of the heart. But Iâ€™m sure we can figure that out.

Once again, this is really a pretty straightforward formula, so letâ€™s jump in and code it up.

```
function heart(xc, yc) {
  for (t = 0; t < 2 * PI; t += 0.01) {
    x = 16 * pow(sin(t), 3)
    y = 13 * cos(t) - 5 * cos(2 * t) - 2 * cos(3 * t) - cos(4 * t)
    lineTo(xc + x, yc + y)
  }
  closePath()
}
```

We can run this like so:

```
canvas(600, 600)
heart(300, 300)
stroke()
```

And weâ€™ll get:

![image](./images/ch14/out-9.png)

Generally right, but we need to flip it like before, and we need to allow for changing the size. Right now itâ€™s about 32 pixels wide. Thatâ€™s the hard coded 16, times 2.

For flipping we can again just say yc - y.

For size, letâ€™s first get rid of all of those hard-coded numbers by dividing them all by 16.

```
x = pow(sin(t), 3)
y = 0.8125 * cos(t) - 0.3125 * cos(2 * t) - 0.125 * cos(3 * t) - 0.0625 * cos(4 * t)
```

If we left it like that, weâ€™d get a heart that would be two pixels wide (1 * 2). Now we can add a size parameter and multiply both values by that.

```
function heart(xc, yc, size) {
  for (t = 0; t < 2 * PI; t += 0.01) {
    x = size * pow(sin(t), 3)
    y = size * (0.8125 * cos(t) - 0.3125 * cos(2 * t) - 0.125 * cos(3 * t) - 0.0625 * cos(4 * t))
    lineTo(xc + x, yc - y)
  }
  closePath()
}
```

Now we call it like so:

```
canvas(600, 600)
heart(300, 300, 280)
stroke()
```

And get:

![image](./images/ch14/out-10.png)


Not too difficult.

Iâ€™m not going to dive in to all the different ways you can mess with this, but just try changing the various constants in the formula and see what happens. Can you make it better? Come up with something completely different?

## An Egg

I first looked into drawing egg shapes a couple of years ago. This post showed the result, but none of the thought process behind it: https://www.bit-101.com/blog/2021/06/how-to-draw-an-egg/

The page I got my formula from was here: http://www.mathematische-basteleien.de/eggcurves.htm

There are actually a truckload of different egg formulas on that page. Like the heart curve, I was surprised that there was no single standard egg curve formula.

But I homed in on the one on that page under the section â€œFrom the Oval to the Egg Shapeâ€. This takes a general formula for an oval or ellipse and alters the â€œy radiusâ€ based on the current value at each point. If x is to the right of center, it will make the y value a little bit bigger. If x is to the left, it will make the y value a bit smaller. That seemed sensible.

So weâ€™ll start with an ellipse formula. We covered that back in Chapter 3.

```
function ellipse(x, y, rx, ry) {
  res = 4.0 / max(rx, ry)
  for (t = 0; t < 2 * PI; t += res) {
    lineTo(x + cos(t) * rx, y + sin(t) * ry)
  }
  closePath()
}
```

Thatâ€™s nice and concise, but Iâ€™m gonna break it up a bit so we can mess with the raw x and y coords right out of the trig functions before translating and scaling them. Iâ€™m also going to ignore the res variable and just hard code the 0.01 in there. Just for simplicity and clarity. Keep it if you want.

```
function egg(xc, yc, rx, ry) {
  for (t = 0; t < 2 * PI; t += 0.01) {
    x = cos(t)
    y = sin(t)
    lineTo(xc + x * rx, yc + y * ry)
  }
  closePath()
}
```

This will just draw an ellipse, but letâ€™s make sure it works with the changes.

```
canvas(600, 600)
egg(300, 300, 280, 190)
stroke()
```

![image](./images/ch14/out-11.png)

Yup, thatâ€™s an ellipse. Where did I get the 280 and 190 from? Well, 280 is a bit less than half of the width of the canvas, so thatâ€™s the rx. And I wanted ry to be somewhat less than that. It was just trial and error and 190 looked about right.

Now letâ€™s make this ellipse into an egg. The article gives three formulas:

```
t1(x) = 1 + 0.2 * x
 
t2(x) = 1 / (1 - 0.2 * x)
 
t3(x) = e^(0.2 * x)
```

Those t functions just give us something we need to multiply the y value by. Iâ€™m not going to make new functions though. Iâ€™m just going to do the multiplication right in the for loop. Letâ€™s try the first oneâ€¦

```
function egg(xc, yc, rx, ry) {
  for (t = 0; t < 2 * PI; t += 0.01) {
    x = cos(t)
    y = sin(t)
    y *= (1 + 0.2 * x)
    lineTo(xc + x * rx, yc + y * ry)
  }
  closePath()
}
```

![image](./images/ch14/out-12.png)

Woo! An egg!

Now we can mess with that a bit. The 0.2 value there is probably going to be the best source of experimentation. Letâ€™s try 0.3.

![image](./images/ch14/out-13.png)

OK, it got a bit pointy. How about 0.5?

![image](./images/ch14/out-14.png)

Even pointier. So we know where thatâ€™s going. Letâ€™s go down. To 0.1.

![image](./images/ch14/out-15.png)


Thatâ€™s barely distinguishable from the original ellipse. Which makes sense, because if that value was 0, than that line would do nothing and weâ€™d be back to an ellipse. Letâ€™s go back to 0.2, which probably did look the most egg-like, and try changing the yr value weâ€™re passing in. Weâ€™ve been using 190. Hereâ€™s 220:

![image](./images/ch14/out-16.png)

A nice fat egg. And 150:

![image](./images/ch14/out-17.png)

Iâ€™m gonna stand by my choice of 190, but some minor tweaks might work better. Go for it. Letâ€™s try the other formulas. Weâ€™ll go back to the ry of 190 first. Then change that line 5 to:

```
y *= 1 / (1 - 0.2*x)
```

This gives us:

![image](./images/ch14/out-18.png)

And then the third formula:

```
y *= exp(0.2 * x)
```

Remember from Chapter 5 that most math libraries have an exp function that is e raised to a given power. Thatâ€™s what we are doing here. The result of that:

![image](./images/ch14/out-19.png)

These all look suspiciously the same, so I drew them all at once, red, green and blueâ€¦

![image](./images/ch14/out-20.png)

Yeah, those are all virtually the same. Maybe a pixel off here and there. Looking back at the original web site, they are talking about a different ellipse formula and multiplying y2 by that value:

> The equation of the ellipse e.g. xÂ²/9+yÂ²/4=1 change to xÂ²/9+yÂ²/4*t(x)=1.

This is also hard coding 9 and 4 as divisors. If you unsquare those you get 3 and 2. And it just so happens that 2/3 of 280 is 186ish. So we pretty much agreed on my choice of 190 for ry!

At any rate, we have a formula that draws a fairly convincing egg no matter which algorithm we use. So Iâ€™m going to leave it there. Here I was literally writing the article as I was writing the code, so you really got to see my process, along with my glossing over of details in the source article. But it all came out just fine!

## Summary

Hopefully this gives you some insight on how to find formulas in various places and convert them into code that draws something interesting â€“ if you havenâ€™t already done stuff like this.

And that wraps up this series on coding curves. At least for now. I have another series in mind though, so watch this space!



